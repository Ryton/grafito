#!/usr/bin/env arturo
;========================================================
; Grafito
;
; SQLite-based Graph Database
; in Arturo
;--------------------------------------------------------
;; name: grafito
;; version: 0.2.8
;; author: drkameleon
;; website: « https://github.com/arturo-lang/grafito
;; category: database
;========================================================

;--------------------------
; The main library
;--------------------------

Grafito: #[
    Debug: false ;true
    Version: 0.2.8
]

graph: function [
    dbpath :string :null
    body :block
][
    ;; description: « initiate a new graph environment with given name and body
    ;; options: [
    ;;      create: « recreate database from scratch, even if it exists
    ;;      case: « queries should be case-sensitive
    ;;      verbose: « show messages regarding database operations
    ;; ]
    ;; returns: :any
    ;; example: {
    ;;      graph "mydb" [
    ;;          ; do sth with this graph database
    ;;      ]
    ;;      ;;;;
    ;;      ; in memory database
    ;;      graph ø [
    ;;          ; do sth with this graph database
    ;;      ]
    ;; }

    ;==========================================
    ; CONSTANTS
    ;==========================================

    ; Global SQL scripts

    schemaSQL:              split.by:";" read "sql/schema.sql"

    createNodeSQL:          read "sql/createNode.sql"
    updateNodeSQL:          read "sql/updateNode.sql"
    deleteNodeSQL:          read "sql/deleteNode.sql"
    deleteNodeEdgesSQL:     read "sql/deleteNodeEdges.sql"
    getNodeSQL:             read "sql/getNode.sql"
    getRelatedNodesSQL:     read "sql/getRelatedNodes.sql"
    getMaxNodeIdSQL:        read "sql/getMaxNodeId.sql"

    createEdgeSQL:          read "sql/createEdge.sql"
    deleteEdgeSQL:          read "sql/deleteEdge.sql"

    fetchNodesSQL:          read "sql/fetchNodes.sql"
    fetchNodesWithEdgesSQL: read "sql/fetchNodes.withEdges.sql"

    ; Global SQL filters

    hasEdgeFilter:              read "sql/filters/hasEdge.sql"
    hasPropertyFilter:          read "sql/filters/hasProperty.sql"
    edgeWithTargetFilter:       read "sql/filters/edgeWithTarget.sql"
    propertyWithValueFilter:    read "sql/filters/propertyWithValue.sql"

    ; Global UI template

    app: read "ui/index.html"

    ; Color library
    ; for graph nodes

    colori: [
        'blue 'blueviolet 'brown 'cadetblue 'chocolate 'crimson 'darkblue 'darkgreen 
        'darkmagenta 'darkorchid 'darkred 'darkslategray 'dodgerblue 'green 'indigo 
        'maroon 'mediumpurple 'midnightblue 'olive 'orange 'orangered 'peru 'purple 
        'seagreen 'steelblue 'teal
    ]

    ;==========================================
    ; HELPERS
    ;==========================================

    ;
    ; Perform query
    ;--------------------------

    performQuery: function [ctx, qu, params][
        if and? [Grafito\Debug][null? attr 'noDebug] [
            context: to :string ctx
            prepend: " | "
            print color.bold #gray ">: " ++ context
            
            queryString: qu
            if block? qu [
                queryString: join.with:"\n" qu
            ]

            print color #gray prepend ++ join.with:"\n"++prepend split.lines queryString

            print ""
        ]
        if? not? null? params [
            query db .with: params qu
        ]
        else [
            query db qu
        ]
    ]

    ;
    ; Print message
    ;--------------------------

    printDebug: function [msg][
        print color #cyan ":: " ++ msg
    ]

    ;
    ; Get random node color
    ; for graph visualization
    ;--------------------------

    addColorForNodeType: function [nn, existingCl][
        if? not? key? nodeConfig nn\tag [
            cl: sample colori
            while [contains? existingCl cl][
                cl: sample colori
            ]
            ;print ~"picked |cl|"
            remove 'colori cl
            set nodeConfig nn\tag #[
                color: cl
                label: get keys nn\properties 0
            ]
            return cl
        ]
        else [
            return null
        ]
    ]

    ;
    ; Create new edge
    ;--------------------------

    edge: function [
        src :dictionary 
        name :literal :string
        tgt :dictionary
    ][
        ;; description: « create edge from source to target node with given name
        ;; returns: :dictionary

        edgeId: performQuery.id 'edge createEdgeSQL @[name, src\id, tgt\id]

        #[
            id: edgeId
            tag: name
            source: src
            target: tgt
        ]
    ]

    ;
    ; Delete existing edge
    ;--------------------------

    unedge: function [
        src :dictionary
        name :literal :string
        tgt :dictionary
    ][
        ;; description: « delete edge from source to target node with given name

        performQuery 'unedge deleteEdgeSQL @[src\id, tgt\id]
    ]

    ;
    ; Get node with properties
    ; from ID
    ;--------------------------

    nodeFromId: function [nid][
        results: performQuery 'nodeFromId getNodeSQL @[nid]
        
        if empty? results ->
            return ø 

        return #[
            id: nid
            tag: first first results
            properties: read.json last first results
        ]
    ]

    ;
    ; Get nodeset 
    ; for graph visualization
    ;--------------------------

    nodeFromIds: function [nodes][
        nodeset: new nodes
        if not? block? nodeset [
            nodeset: new @[nodeset]
        ]

        clean: new nodeset

        edz: new []
        usedColors: new []

        loop nodeset [nd][
            'usedColors ++ addColorForNodeType nd usedColors

            rezu: performQuery 'nodeFromIds getRelatedNodesSQL @[nd\id, nd\id, nd\id]

            loop rezu [rez][
                appendable: #[
                    id: rez\0
                    tag: rez\1
                    properties: read.json rez\2
                ]

                'clean ++ appendable
                'usedColors ++ addColorForNodeType appendable usedColors
                'edz ++ @[@[rez\3 rez\4 rez\5]]
            ]
            clean: unique clean
        ]

        elements: new []

        loop clean [nd][
            t: nd\tag
            props: nd\properties
            nconf: nodeConfig\[t]
            
            'elements ++ #[
                id: to :integer nd\id
                tag: t
                properties: props
                label: truncate get props nconf\label 10
                color: nconf\color
            ]
        ]

        relations: new []

        loop edz [ed][
            'relations ++ #[ 
                id: ~"|ed\0|+|ed\1|+|ed\2|"
                from: to :integer ed\0
                to: to :integer ed\1
                label: ed\2
            ]
        ]

        return #[
            nodes: unique elements
            edges: unique relations
        ]
    ]

    ;
    ; Generate access helper
    ;--------------------------
    generateHelper: function [id,block][
        if? not? null? attr 'new [
            put id block
        ]
        else [
            fetch id block
        ]
    ]

    ;==========================================
    ; REPL
    ;==========================================

    ;
    ; Switch verbosity on/off
    ;--------------------------

    verbose: function [] .export:[verbose?] [
        verbose?: not? verbose?
    ]

    ;==========================================
    ; METHODS
    ;==========================================

    ;
    ; Create new node
    ;--------------------------
    
    put: function [
        name :literal :string
        attributes :block :dictionary
    ][
        ;; description: « insert new node(s) to graph with given name and attributes
        ;; options: [
        ;;      unique: « add only if node doesn't already exist
        ;;      many: « add multiple nodes at once
        ;; ]
        ;; returns: :dictionary :block

        if attr "unique" [
            found: fetch name attributes
            if not? empty? found -> return found
        ]

        result: new []

        if? not? null? attr 'many [
            lastId: to :integer first first performQuery 'put getMaxNodeIdSQL ø
            queries: new []
            vals: new []
            loop attributes 'nd [
                lastId: lastId + 1
                att: nd
                if not? dictionary? att -> att: #att
                'queries ++ createNodeSQL
                'vals ++ @[name, write.json ø att]
                'result ++ #[
                    id: lastId
                    tag: name
                    properties: att
                ]
            ]
            performQuery 'put queries vals

            if verbose? ->
                 printDebug ~{created |size attributes| nodes}
        ]
        else [
            att: attributes
            if not? dictionary? att -> att: #att
            nodeId: performQuery.id 'put createNodeSQL @[name, write.json ø att]
            result: #[
                id: nodeId
                tag: name
                properties: att
            ]

            if verbose? ->
                printDebug ~{created 1 node (@|nodeId|) with |size att| propert|if? 1 = size att -> "y" else -> "ies"|}
        ]
    
        return result
    ]

    ;
    ; Update existing node
    ;--------------------------

    edit: function [
        nd :dictionary :block
        attributes :block :dictionary
    ][
        ;; description: « update given node(s) with attributes
        ;; options: [
        ;;      replace: « replace entire object properties with given ones
        ;; ]
        ;; returns: :nothing

        toUpdate: ø

        if? dictionary? nd ->
            toUpdate: @[nd]
        else ->
            toUpdate: new nd

        doReplace?: not? null? attr 'replace

        additional: attributes
        if block? additional ->
            additional: # additional

        loop toUpdate 'updateable [
            newAttributes: ø

            if? doReplace? ->
                newAttributes: additional
            else ->
                newAttributes: extend updateable\properties additional

            updateable\properties: newAttributes
            performQuery 'reput updateNodeSQL @[write.json ø newAttributes, updateable\id]
        ]
    ]

    ;
    ; Delete existing node
    ;--------------------------

    unput: function [
        nd :dictionary :block
    ][
        ;; description: « remove given node(s) from graph
        ;; returns: :nothing

        toDelete: ø

        if? dictionary? nd ->
            toDelete: @[nd]
        else ->
            toDelete: new nd

        loop toDelete 'deletable [
            performQuery 'unput @[
                deleteNodeSQL, deleteNodeEdgesSQL
            ] @[
                deletable\id, deletable\id, deletable\id 
            ]
        ]
    ]

    ;
    ; Link nodes with edges
    ;--------------------------

    link: function [
        src :block :dictionary
        name :literal :string
        tgt :block :dictionary
    ]
    [
        ;; description: « create a connection from source to target node with given name
        ;; returns: :block :dictionary

        edgeId: 0

        if? :dictionary = type tgt [
            edges: new []
            if :dictionary = type src [
                ret: edge src name tgt
                return ret
            ]

            sr: @ src
            loop sr [s]->
                'edges ++ edge s name tgt
        
            if verbose? -> printDebug ~"created |size edges| edges"

            return edges
        ]
        else [
            edges: new []
            tg: @ tgt
            if? :dictionary = type src [
                loop tg [t]->
                    'edges ++ edge src name t
            ]
            else [
                sr: @ src
                loop sr [s] [
                    loop tg [t]->
                        'edges ++ edge s name t
                ]
            ]

            if verbose? -> printDebug ~"created |size edges| edges"

            return edges
        ]
    ]

    ;
    ; Delete node edges
    ;--------------------------

    unlink: function [
        name :literal :string
        src :dictionary
        tgt :dictionary
    ][
        ;; description: « remove connection from source to target node with given name

        edgeId: 0

        if? :dictionary = type tgt [
            unedge src name tgt
            if verbose? -> printDebug ~"removed 1 edge"
        ]
        else [
            if? :dictionary = type src [
                loop tgt [t]->
                    unedge src name t
            ]
            else [
                loop src [s] [
                    loop tgt [t]->
                        unedge s name t
                ]
            ]

            if verbose? -> printDebug ~"removed |size edges| edges"
        ]
    ]

    ;
    ; Check node type
    ;--------------------------
    
    isA?: function [ls,nd][
        nd\tag = to :string ls
    ]

    ;
    ; Fetch all results for tag
    ; with given properties
    ; and edges
    ;--------------------------

    fetch: function [
        name :literal :string
        attributes :null :block :dictionary
    ][
        ;; description: « retrieves nodes with name that match all given attributes
        ;; options: [
        ;;      .any « try matching any of the attributes
        ;; ]
        ;; returns: :block
        
        catchAny?: false
        if? not? null? attr "any" ->
            catchAny?: true

        att: new attributes

        if and? not? dictionary? att 
                not? null? att ->
            att: #att

        ; HACK - to solve
        remove.key 'att 'n
        remove.key 'att 'a

        propertyFilters: new []
        edgeFilters: new []
        qvals: new @[name]
        qpropvals: new []
        qedgevals: new []

        if not? empty? att [
            loop att [k,v][
                case [equal? type v]
                    when? [:null][
                        ; it's an edge filter without criteria
                        'edgeFilters ++ hasEdgeFilter
                        'qedgevals ++ @[k]
                    ]
                    when? [:dictionary][
                        ; it's an edge filter
                        'edgeFilters ++ edgeWithTargetFilter
                        'qedgevals ++ @[k, v\id]
                    ]
                    when? [:block][
                        if? and? 0 < size v 
                                 :dictionary = type first v [
                            ; it's an array of edge filters
                            orCriteria: new []
                            loop v [edgef][
                                'orCriteria ++ {!sql (edges.tag=? AND edges.target=?)}
                                'qedgevals ++ @[k, edgef\id]
                            ]
                            'edgeFilters ++ "(" ++ (join.with:" OR " orCriteria) ++ ")"
                        ]
                        else [
                            ; it's a complex property filter
                            loop #v [filt,rg][

                                [symb,val]: @["=", v]

                                case [equal? filt]
        
                                    when? ["contains"]      -> [symb,val]: @["LIKE", ~"%|rg|%"]
                                    when? ["prefix"]        -> [symb,val]: @["LIKE", ~"|rg|%"]
                                    when? ["suffix"]        -> [symb,val]: @["LIKE", ~"%|rg|"]
                                    when? ["under"]         -> [symb,val]: @["<", rg]
                                    when? ["over"]          -> [symb,val]: @[">", rg]
                                    when? ["underOrEqual"]  -> [symb,val]: @["<=", rg]
                                    when? ["overOrEqual"]   -> [symb,val]: @[">=", rg]
                                    when? ["in"]            -> [symb,val]: @["IN", ~{(|join.with:", " map rg [x]["'" ++ (to :string x) ++ "'"]|)}]
                                    when? ["not"][     
                                        if? block? rg       -> [symb,val]: @["NOT IN", ~{(|join.with:", " map rg [x]["'" ++ (to :string x) ++ "'"]|)}]
                                        else                -> [symb,val]: @["!=", rg]
                                    ]
                                    else [
                                        panic.code: 1 ~"filter: |filt| not recognized"
                                    ]
                                
                                val: as.code val
                                'propertyFilters ++ ~propertyWithValueFilter
                                'qpropvals ++ @[~"$.|k|"]
                            ]
                        ]
                    ]
                    when? [:logical][
                        ; it's a simple property filter without criteria
                        'propertyFilters ++ hasPropertyFilter
                        'qpropvals ++ @[~"$.|k|"]
                    ]
                    else [
                        ; it's a simple property filter
                        symb: "="
                        val: as.code v
                        'propertyFilters ++ ~propertyWithValueFilter
                        'qpropvals ++ @[~"$.|k|"]
                    ]
            ]
        ]

        qr: ""

        propies: ""
        linker: " AND "
        edgeLimit: ~" = |size edgeFilters|"

        if catchAny? [
            linker: " OR "
            edgeLimit: " >= 1"
        ]

        if not? empty? propertyFilters ->
            propies: ~{!sql AND (|join.with: linker propertyFilters|)}
            'qvals ++ qpropvals

        if? not? empty? edgeFilters [
            edgies: join.with: " OR " edgeFilters
            'qvals ++ qedgevals

            qr: ~fetchNodesWithEdgesSQL
        ]
        else [
            qr: ~fetchNodesSQL
        ]

        return map performQuery 'fetch qr qvals 'x [
            #[
                id: x\0
                tag: x\1
                properties: read.json x\2
            ]
        ]
    ]

    ;
    ; Visualize given nodeset
    ;--------------------------

    preview: function [
        nodeset :block
    ][
        ;; description: « preview given set of nodes in Grafito's UI
        ;; options: [
        ;;      server: « start Grafito as a server
        ;; ]

        currentNodes: new nodeset
        currentDataset: new nodeFromIds currentNodes

        Versions: #[
            engine: to :version first split.by:" " execute "sqlite3 --version"
            system: Grafito\Version
        ]
        
        routes: #.raw[
            "/"             [
                render.template app
            ]

            "/startup" [
                write.json ø #[
                    title: cleanpath
                    data: currentDataset
                    rows: currentNodes
                    versions: Versions
                ]
            ]

            "/exec"         [
                try? [
                    if verbose? ->
                        printDebug "<== " ++ command
                    currentNodes: ""
                    bench: benchmark.get [
                        currentNodes: new do command
                    ]
                    if verbose? -> 
                        printDebug ~"==> OK (|bench| ms)"
                    if? or? [not? block? currentNodes]
                            [and? [0 < size currentNodes][not? dictionary? first currentNodes]][
                        "empty"
                    ]
                    else [
                        currentDataset: new nodeFromIds currentNodes
                        write.json ø #[
                            data: currentDataset
                            rows: currentNodes
                            timeTaken: bench
                        ]
                    ]
                ]
                else [
                    "error"
                ]
            ]

            "/nodeFromId"   [
                newNodes: new nodeFromIds @[nodeFromId ndid]
                write.json ø newNodes
            ]

            "/styles/app.less"  [
                read "ui/styles/app.less"
            ]

            "/styles/app.css"  [
                read "ui/styles/app.css"
            ]

            "/scripts/app.js" [
                read "ui/scripts/app.js"
            ]

            "/exit" [
                printDebug "Shutting down"
                close db
                exit
            ]
        ]

        if? null? attr 'server [
            serve.chrome routes
        ]
        else [
            serve.verbose routes
        ]
    ]

    ;==========================================
    ; INITIALIZATION
    ;==========================================

    ; basic setup
    verbose?: not? null? attr 'verbose
    caseSensitive?: not? null? attr 'case

    dbPath: ""
    cleanpath: "in-memory"
    dbExisted: false

    if not? null? dbpath [
        cleanpath: extract.filename dbpath
        dbPath: ~"|cleanpath|.db"
        dbExisted: exists? ~"|cleanpath|.db"
    ]

    nodeConfig: #[]

    ; define aliases
    alias.infix {~>} 'link

    ; open the database
    printDebug ~"DB = |cleanpath|"
    db: open dbPath

    ; and initialize it
    ; with the given schema (if necessary)
    if? or? not? null? attr "create"
            not? dbExisted [
        printDebug "creating database from scratch"
        performQuery.noDebug 'main schemaSQL ø
        
        metas: #[]

        set metas 'version "undefined"
        set metas 'mode "json"
        set metas 'version Grafito\Version

        put'meta metas
        pop.discard 1
    ] 
    else [
        printDebug "using existing database"
    ]

    ; create helpers, if any
    entities: attr "helpers"
    if null? entities -> entities: []
    ei: new 0
    while [ei < size entities].import [
        entity: to :literal entities\[ei]
        let entity function [block] with 'entity -> generateHelper entity block
        inc 'ei
    ]

    ; process body
    result: do body

    ; close the database
    close db

    ; and that was it :)
    return result
]

;--------------------------
; The main entry point
;--------------------------

if standalone? [
    ; helpers & templates

    Versions: #[
        engine: to :version first split.by:" " execute "sqlite3 --version"
        system: script\version
    ]

    BR: "\n"

    logoTxt: read "logo.txt"

    GrafitoHeader: join @[
        print color #magenta replace.regex logoTxt "#(.+)" (color #white "$1") ++ color.keep #magenta ""
        print "  "
        color #gray "-------------------------------------" BR
        color #gray ~"  system: v/|Versions\system|, engine: v/|Versions\engine|" BR
        color #gray "-------------------------------------" BR
    ]

    ; methods

    launchTerminal: function [][
        completions: ["fetch" "put" "unput" "link" "unlink" "edge" "unedge"]
        historyPath: join.path @[path\home ".arturo" "grafito-history.lst"]

        print ""
        print color #orange "## Tip: Type `verbose` to switch info messages on/off"
        print color #orange "## Launching Grafito console - rock on! 🤘"
        print ""

        while ø .import [
            Got: null

            indentation: ""
            
            inp: input .repl
                    .history: historyPath 
                    .complete: completions
                    "$> " 

            while [suffix? inp " "][
                if suffix? strip inp "[" [
                    indentation: indentation ++ "\t"
                ]
                inp: inp ++ input ".. " ++ indentation
            ]

            try?.verbose.import [
                try.verbose.import to :block inp

                StackSize: size stack
                
                if StackSize > 0 		-> Got: pop 1
                if Got <> null 			-> print color #gray ~"=> |Got|"

                print ""
            ]
            else [
                print ""
            ]
        ]
    ]

    ; startup

    print GrafitoHeader

    if 1 < size arg ->
        panic "Too many arguments given!"

    dbInput: ø
    if 1 = size arg -> 
        dbInput: arg\0

    graph dbInput [
        launchTerminal
    ]
]

;==========================================
; This is the end,
; my only friend, the end...
;==========================================