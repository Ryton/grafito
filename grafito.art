#!/usr/bin/env arturo
;========================================================
; Grafito
;
; SQLite-based Graph Database
; in Arturo
;--------------------------------------------------------
;; name: grafito
;; version: 0.2.8
;; author: drkameleon
;; website: « https://github.com/arturo-lang/grafito
;; category: database
;========================================================

;--------------------------
; The main library
;--------------------------

Debug: true

graph: function [
    dbpath :string :null
    body :block
][
    ;; description: « initiate a new graph environment with given name and body
    ;; options: [
    ;;      create: « recreate database from scratch, even if it exists
    ;;      verbose: « show messages regarding database operations
    ;; ]
    ;; returns: :any
    ;; example: {
    ;;      graph "mydb" [
    ;;          ; do sth with this graph database
    ;;      ]
    ;;      ;;;;
    ;;      ; in memory database
    ;;      graph ø [
    ;;          ; do sth with this graph database
    ;;      ]
    ;; }

    ;==========================================
    ; CONSTANTS
    ;==========================================

    ; Global SQL scripts

    schemaSQL:          split.by:";" read "sql/schema.sql"

    createNodeSQL:      read "sql/createNode.sql"
    deleteNodeSQL:      read "sql/deleteNode.sql"
    deleteNodeEdgesSQL: read "sql/deleteNodeEdges.sql"
    getNodeSQL:         read "sql/getNode.sql"
    getRelatedNodesSQL: read "sql/getRelatedNodes.sql"

    createEdgeSQL:      read "sql/createEdge.sql"
    deleteEdgeSQL:      read "sql/deleteEdge.sql"

    ; Global UI template

    app: read "ui/index.html"

    ; Color library
    ; for graph nodes

    colori: [
        'blue 'blueviolet 'brown 'cadetblue 'chocolate 'crimson 'darkblue 'darkgreen 
        'darkmagenta 'darkorchid 'darkred 'darkslategray 'dodgerblue 'green 'indigo 
        'maroon 'mediumpurple 'midnightblue 'olive 'orange 'orangered 'peru 'purple 
        'seagreen 'steelblue 'teal
    ]

    ;==========================================
    ; METHODS
    ;==========================================

    ;
    ; Perform query
    ;--------------------------

    performQuery: function [ctx, qu, params][
        if and? [Debug][null? attr 'noDebug] [
            context: to :string ctx
            prepend: " | "
            print color.bold #gray ">: " ++ context
            print color #gray prepend ++ join.with:"\n"++prepend split.lines qu

            print ""
        ]
        if? not? null? params [
            query db .with: params qu
        ]
        else [
            query db qu
        ]
    ]

    ;
    ; Print message
    ;--------------------------

    printDebug: function [msg][
        print color #cyan ":: " ++ msg
    ]

    ;
    ; Get random node color
    ; for graph visualization
    ;--------------------------

    addColorForNodeType: function [nn, existingCl][
        if? not? key? nodeConfig nn\tag [
            cl: sample colori
            while [contains? existingCl cl][
                cl: sample colori
            ]
            ;print ~"picked |cl|"
            remove 'colori cl
            set nodeConfig nn\tag #[
                color: cl
                label: get keys nn\properties 0
            ]
            return cl
        ]
        else [
            return null
        ]
    ]

    ;
    ; Create new node
    ;--------------------------
    
    put: function [
        name :literal :string
        attributes :block :dictionary
    ][
        ;; description: « insert new node to graph with given name and attributes
        ;; options: 
        ;;      unique: « add only if node doesn't already exist"
        ;; ]
        ;; returns: :dictionary

        if attr "unique" [
            found: fetch name attributes
            if not? empty? found -> return found
        ]

        att: attributes
        if not? dictionary? att -> att: #att
        nodeId: performQuery.id 'put createNodeSQL @[name, write.json ø att]

        if verbose? [
            printDebug ~{created 1 node (@|nodeId|) with |size att| propert|if? 1 = size att -> "y" else -> "ies"|}
        ]
    
        return #[
            id: nodeId
            tag: name
            properties: att
        ]
    ]

    ;
    ; Delete existing node
    ;--------------------------

    unput: function [
        nd :dictionary :block
    ][
        ;; description: « remove given node(s) from graph

        toDelete: ø

        if? dictionary? nd ->
            toDelete: @[nd]
        else ->
            toDelete: new nd

        loop toDelete 'deletable [
            performQuery 'unput @[
                deleteNodeSQL, deleteNodeEdgesSQL
            ] @[
                deletable\id, deletable\id, deletable\id 
            ]
        ]
    ]

    ;
    ; Create new edge
    ;--------------------------

    edge: function [
        src :dictionary 
        name :literal :string
        tgt :dictionary
    ][
        ;; description: « create edge from source to target node with given name
        ;; returns: :dictionary

        edgeId: performQuery.id 'edge createEdgeSQL @[name, src\id, tgt\id]

        #[
            id: edgeId
            tag: name
            source: src
            target: tgt
        ]
    ]

    ;
    ; Delete existing edge
    ;--------------------------

    unedge: function [
        src :dictionary
        name :literal :string
        tgt :dictionary
    ][
        ;; description: « delete edge from source to target node with given name

        performQuery 'unedge deleteEdgeSQL @[src\id, tgt\id]
    ]

    ;
    ; Get node with properties
    ; from ID
    ;--------------------------

    nodeFromId: function [nid][
        results: performQuery 'nodeFromId getNodeSQL @[nid]
        
        if empty? results ->
            return ø 

        return #[
            id: nid
            tag: first first results
            properties: read.json last first results
        ]
    ]

    ;
    ; Link nodes with edges
    ;--------------------------

    link: function [
        src :block :dictionary
        name :literal :string
        tgt :block :dictionary
    ]
    [
        ;; description: « create a connection from source to target node with given name
        ;; returns: :block :dictionary

        edgeId: 0

        if? :dictionary = type tgt [
            edges: []
            if :dictionary = type src [
                ret: edge src name tgt
                return ret
            ]

            sr: @ src
            loop sr [s]->
                append 'edges edge s name tgt
        
            if verbose? -> printDebug ~"created |size edges| edges"

            return edges
        ]
        else [
            edges: []
            tg: @ tgt
            if? :dictionary = type src [
                loop tg [t]->
                    append 'edges edge src name t
            ]
            else [
                sr: @ src
                loop sr [s] [
                    loop tg [t]->
                        append 'edges edge s name t
                ]
            ]

            if verbose? -> printDebug ~"created |size edges| edges"

            return edges
        ]
    ]

    ;
    ; Delete node edges
    ;--------------------------

    unlink: function [
        name :literal :string
        src :dictionary
        tgt :dictionary
    ][
        ;; description: « remove connection from source to target node with given name

        edgeId: 0

        if? :dictionary = type tgt [
            unedge src name tgt
            if verbose? -> printDebug ~"removed 1 edge"
        ]
        else [
            if? :dictionary = type src [
                loop tgt [t]->
                    unedge src name t
            ]
            else [
                loop src [s] [
                    loop tgt [t]->
                        unedge s name t
                ]
            ]

            ; if verbose? -> printDebug ~"created |size edges| edges"
        ]
    ]

    ;
    ; Check node type
    ;--------------------------
    
    isA?: function [ls,nd][
        nd\tag = to :string ls
    ]

    ;
    ; Fetch all results for tag
    ; with given properties
    ; and edges
    ;--------------------------

    fetch: function [
        name :literal :string
        attributes :null :block :dictionary
    ][
        ;; description: « retrieves nodes with name that match all given attributes
        ;; options: [
        ;;      .any « try matching any of the attributes
        ;; ]
        ;; returns: :block
        
        catchAny?: false
        if? not? null? attr "any" ->
            catchAny?: true

        att: new attributes

        if and? not? dictionary? att 
                not? null? att ->
            att: #att

        ; HACK - to solve
        remove.key 'att 'n
        remove.key 'att 'a

        propertyFilters: new []
        edgeFilters: new []

        if not? empty? att [
            loop att [k,v][
                case [equal? type v]
                    when? [:null][
                        ; it's an edge filter without criteria
                        append 'edgeFilters ~{!sql (edges.tag='|k|')}
                    ]
                    when? [:dictionary][
                        ; it's an edge filter
                        append 'edgeFilters ~{!sql (edges.tag='|k|' AND edges.target=|v\id|)}
                    ]
                    when? [:block][
                        if? and? 0 < size v 
                                 :dictionary = type first v [
                            ; it's an array of edge filters
                            orCriteria: new []
                            loop v [edgef][
                                'orCriteria ++ ~{!sql (edges.tag='|k|' AND edges.target=|edgef\id|)}
                            ]
                            append 'edgeFilters "(" ++ (join.with:" OR " orCriteria) ++ ")"
                        ]
                        else [
                            ; it's a complex property filter
                            loop #v [filt,arg][

                                symb: "="
                                val: ~"'|v|'"

                                case [equal? filt]
                                    when? ["contains"]          [symb: "LIKE"   val: ~"'%|arg|%'"]
                                    when? ["prefix"]            [symb: "LIKE"   val: ~"'|arg|%'"]
                                    when? ["suffix"]            [symb: "LIKE"   val: ~"'%|arg|'"]
                                    when? ["under"]             [symb: "<"      val: arg]
                                    when? ["over"]              [symb: ">"      val: arg]
                                    when? ["underOrEqual"]      [symb: "<="     val: arg]
                                    when? ["overOrEqual"]       [symb: ">="     val: arg]
                                    when? ["not"]               [     
                                        if? block? arg [
                                            symb: "NOT IN" val: ~{(|join.with:", " map arg [x]["'" ++ (to :string x) ++ "'"]|)}
                                        ]
                                        else [
                                            symb: "!="
                                            val: ~"'|arg|'"
                                        ]   
                                    ]
                                    when? ["in"]                [symb: "IN"     val: ~{(|join.with:", " map arg [x]["'" ++ (to :string x) ++ "'"]|)}]
                                    else [
                                        panic.code: 1 ~"filter: |filt| not recognized"
                                    ]

                                append 'propertyFilters ~{!sql (json_extract(nodes.properties, '$.|k|') |symb| |val|)} 
                            ]
                        ]
                    ]
                    when? [:boolean][
                        ; it's a simple property filter without criteria
                        append 'propertyFilters ~{!sql (properties.property='|k|')} 
                    ]
                    else [
                        ; it's a simple property filter
                        append 'propertyFilters ~{!sql (json_extract(nodes.properties, '$.|k|')='|v|')} 
                    ]
            ]
        ]

        qr: ""

        propies: ""
        linker: " AND "

        if catchAny? ->
            linker: " OR "

        if not? empty? propertyFilters ->
            propies: ~{!sql AND (|join.with: linker propertyFilters|)}

        qr: ~{!sql
            SELECT nodes.id, nodes.tag, nodes.properties
            FROM nodes
        }

        if not? empty? edgeFilters ->
            qr: qr ++ "\n" ++ {!sql
                INNER JOIN edges
                ON edges.source=nodes.id
            }

        qr: qr ++ "\n" ++ ~{!sql
            WHERE nodes.tag='|name|' |propies|
        }

        if not? empty? edgeFilters [
            countNum: ~" = |size edgeFilters|"
            if catchAny? [
                countNum: " >= 1"
            ]
            qr: qr ++ "\n" ++ ~{!sql
                GROUP BY nodes.id 
                HAVING COUNT( 
                    CASE 
                        WHEN |join.with:" OR " edgeFilters| 
                        THEN 1 
                    END 
                ) |countNum|
            }
        ]

        qr: qr ++ "\nCOLLATE NOCASE"

        return map performQuery 'fetch qr ø 'x [
            #[
                id: x\0
                tag: x\1
                properties: read.json x\2
            ]
        ]
    ]

    ;
    ; Get nodeset 
    ; for graph visualization
    ;--------------------------

    nodeFromIds: function [nodes][
        nodeset: new nodes
        if not? block? nodeset [
            nodeset: new @[nodeset]
        ]

        clean: new nodeset

        edz: new []
        usedColors: new []

        loop nodeset [nd][
            'usedColors ++ addColorForNodeType nd usedColors

            rezu: performQuery 'nodeFromIds getRelatedNodesSQL @[nd\id, nd\id, nd\id]

            loop rezu [rez][
                appendable: #[
                    id: rez\0
                    tag: rez\1
                    properties: read.json rez\2
                ]

                append 'clean appendable
                'usedColors ++ addColorForNodeType appendable usedColors
                append 'edz @[@[rez\3 rez\4 rez\5]]
            ]
            clean: unique clean
        ]

        elements: new []

        loop clean [nd][
            t: nd\tag
            props: nd\properties
            nconf: nodeConfig\[t]
            
            append 'elements #[
                id: to :integer nd\id
                tag: t
                properties: props
                label: get props nconf\label
                color: nconf\color
            ]
        ]

        relations: new []

        loop edz [ed][
            append 'relations #[ 
                id: ~"|ed\0|+|ed\1|+|ed\2|"
                from: to :integer ed\0
                to: to :integer ed\1
                label: ed\2
            ]
        ]

        return #[
            nodes: unique elements
            edges: unique relations
        ]
    ]

    ;
    ; Generate access helper
    ;--------------------------
    generateHelper: function [id,block][
        if? not? null? attr 'new [
            put id block
        ]
        else [
            fetch id block
        ]
    ]

    ;
    ; Visualize given nodeset
    ;--------------------------

    preview: function [
        nodeset :block
    ][
        ;; description: « preview given set of nodes in Grafito's UI
        ;; options: [
        ;;      server: « start Grafito as a server
        ;; ]

        currentNodes: new nodeset
        currentDataset: new nodeFromIds currentNodes
        
        routes: #.raw[
            "/"             [
                dataset: write.json ø currentDataset
                render.template app
            ]

            "/exec"         [
                try? [
                    print ["<==" command]
                    currentNodes: ""
                    bench: benchmark.get [
                        currentNodes: new do command
                    ]
                    inspect currentNodes
                    print ~"=== OK (|bench| ms)"
                    if? or? [not? block? currentNodes]
                            [and? [0 < size currentNodes][not? dictionary? first currentNodes]][
                        "empty"
                    ]
                    else [
                        currentDataset: new nodeFromIds currentNodes
                        write.json ø currentDataset
                    ]
                ]
                else [
                    "error"
                ]
            ]

            "/nodeFromId"   [
                newNodes: new nodeFromIds @[nodeFromId ndid]
                write.json ø newNodes
            ]

            ; "/exit": [
            ;     return ø
            ; ]
        ]

        if? null? attr 'server [
            serve.chrome routes
        ]
        else [
            serve.verbose routes
        ]
    ]

    ;
    ; Switch verbosity on/off
    ;--------------------------

    verbose: function [] .export:[verbose?] [
        verbose?: not? verbose?
    ]

    ;==========================================
    ; INITIALIZATION
    ;==========================================

    ; basic setup
    verbose?: not? null? attr 'verbose

    dbPath: ""
    cleanpath: "in-memory"
    dbExisted: false

    if not? null? dbpath [
        cleanpath: extract.filename dbpath
        dbPath: ~"|cleanpath|.db"
        dbExisted: exists? ~"|cleanpath|.db"
    ]

    nodeConfig: #[]

    ; define aliases
    alias.infix {~>} 'link

    ; open the database
    printDebug ~"DB = |cleanpath|"
    db: open dbPath

    ; and initialize it
    ; with the given schema (if necessary)
    if? or? not? null? attr "create"
            not? dbExisted [
        printDebug "creating database from scratch"
        performQuery.noDebug 'main schemaSQL ø
        
        metas: #[]

        set metas 'version "undefined"
        set metas 'mode "json"

        ; TODO(DB\Meta) script\version doesn't propagate when module is included
        ;  When it's run as a standalone app, it works fine
        ;  labels: bug
        if not? null? script -> 
            set metas 'version script\version

        put'meta metas
        pop.discard 1
    ] 
    else [
        printDebug "using existing database"
    ]

    ; create helpers, if any
    entities: attr "helpers"
    if null? entities -> entities: []
    ei: new 0
    while [ei < size entities].import [
        entity: to :literal entities\[ei]
        let entity function [block] with 'entity -> generateHelper entity block
        inc 'ei
    ]

    ; process body
    result: do body

    ; close the database
    close db

    ; and that was it :)
    return result
]

;--------------------------
; The main entry point
;--------------------------

if standalone? [
    ; helpers & templates

    Versions: #[
        sqlite: to :version first split.by:" " execute "sqlite3 --version"
        engine: script\version
    ]

    BR: "\n"

    GrafitoHeader: join @[
        print color #magenta append append append {:
                   __ _ _        
                  / _(_) |       
   __ _ _ __ __ _| |_ _| |_ ___  
  / _` | '__/ _` |  _| | __/ _ \ 
 | (_| | | | (_| | | | | || (_) |
  \__, |_|  \__,_|_| |_|\__\___/ 
   __/ |:} color #white "               (c) 2021" color #magenta {:
  |___/:} color #white "       Yanis Zafirópulos"
        print "  "
        color #gray "-----------------------------------" BR
        color #gray ~"  system: v/|Versions\engine|, engine: v/|Versions\sqlite|" BR
        color #gray "-----------------------------------" BR
    ]

    ; methods

    launchTerminal: function [][
        completions: ["fetch" "put" "unput" "link" "unlink" "edge" "unedge"]
        historyPath: join.path @[path\home ".arturo" "grafito-history.lst"]

        print ""
        print color #orange "## Tip: Type `verbose` to switch info messages on/off"
        print color #orange "## Launching Grafito console - rock on! 🤘"
        print ""

        while ø .import [
            Got: null

            indentation: ""
            
            inp: input .repl
                    .history: historyPath 
                    .complete: completions
                    "$> " 

            while [suffix? inp " "][
                if suffix? strip inp "[" [
                    indentation: indentation ++ "\t"
                ]
                inp: inp ++ input ".. " ++ indentation
            ]

            try?.verbose.import [
                try.verbose.import to :block inp

                StackSize: size stack
                
                if StackSize > 0 		-> Got: pop 1
                if Got <> null 			-> print color #gray ~"=> |Got|"

                print ""
            ]
            else [
                print ""
            ]
        ]
    ]

    ; startup

    print GrafitoHeader

    if 1 < size arg ->
        panic "Too many arguments given!"

    dbInput: ø
    if 1 = size arg -> 
        dbInput: arg\0

    graph dbInput [
        launchTerminal
    ]
]

;==========================================
; This is the end,
; my only friend, the end...
;==========================================